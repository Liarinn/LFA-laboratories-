### **Theory:**

Chomsky Normal Form (CNF) is a pivotal concept in formal language theory, providing a standardized representation for context-free grammars (CFGs). Named after the renowned linguist Noam Chomsky, CNF imposes a strict structure on CFGs, facilitating various computational processes and analyses. A CFG is said to be in Chomsky Normal Form if all its production rules adhere to specific patterns.

In CNF, each production rule follows one of the following formats:

1. \(A \rightarrow BC\)
2. \(A \rightarrow a\)
3. \(S \rightarrow ε\)

Here, \(A\), \(B\), and \(C\) are nonterminal symbols, \(a\) is a terminal symbol, and \(S\) is the start symbol. Notably, the third format is only permissible if the empty string (\(ε\)) is part of the language generated by the grammar.

The transformation of a CFG into Chomsky Normal Form involves a series of systematic steps:

1. **START**: Introduce a new start symbol \(S_0\) and a rule \(S_0 \rightarrow S\), where \(S\) is the previous start symbol.
2. **TERM**: Replace rules with nonsolitary terminals by introducing new nonterminal symbols for each terminal.
3. **BIN**: Eliminate right-hand sides with more than two nonterminals by breaking them down into binary productions.
4. **DEL**: Eliminate ε-rules by identifying nullable nonterminals and adjusting productions accordingly.
5. **UNIT**: Eliminate unit rules, which are rules of the form \(A \rightarrow B\), by replacing them with equivalent rules.

The order of these transformations is crucial, as certain operations may affect the applicability or effectiveness of others. For instance, the introduction of ε-rules in the DEL step can disrupt the elimination of unit rules in the UNIT step if not handled appropriately.

Furthermore, CNF conversion serves practical purposes beyond theoretical analysis. Algorithms such as CYK (Cocke–Younger–Kasami) parsing, which operates on CFGs, often require input in Chomsky Normal Form. By preprocessing grammars into CNF, these algorithms can efficiently parse strings and perform syntactic analyses.

Chomsky Normal Form provides a structured framework for expressing context-free grammars, enabling rigorous study and efficient computational processing of formal languages. Its systematic conversion process ensures that CFGs conform to standardized patterns, facilitating a wide range of linguistic and computational applications.

\
### **Objectives:**

1. Learn about Chomsky Normal Form (CNF).
2. Get familiar with the approaches of normalizing a grammar.
3. Implement a method for normalizing an input grammar by the rules of CNF.

    a.The implementation needs to be encapsulated in a method with an appropriate signature (also ideally in an appropriate class/type).
    
    b.The implemented functionality needs executed and tested.
    
    c.A BONUS point will be given for the student who will have unit tests that validate the functionality of the project.
    
    d.Also, another BONUS point would be given if the student will make the aforementioned function to accept any grammar, not only the one from the student's variant.

\

### **Implementation Description:**

\
Understanding Context-Free Grammars:

A context-free grammar (CFG) is a mathematical construct used to describe the syntax of languages. It consists of a set of production rules that define how symbols can be combined to form strings in the language. These rules typically involve terminal symbols (actual language elements) and non-terminal symbols (variables representing groups of language elements).

\
Key Components of the Implementation:

1. **Grammar Representation**:
```
    class ChomskyNormalForm:
        def __init__(self, V_n=None, V_t=None, P=None, S=None, type=None):
            # Constructor code...
        def print_variables(self):
            # Method to print grammar variables...
        def create_grammar(self):
            # Method to interactively create a grammar...
        def check_type_grammar(self):
            # Method to determine the type of grammar...
        def convert_to_Chomsky_Normal_Form(self):
            # Method to convert grammar to CNF...
        def eliminate_epsilon_productions(self):
            # Method to eliminate epsilon productions...
        def eliminate_unit_productions(self):
            # Method to eliminate unit productions...
        def eliminate_unproductive_symbols(self):
            # Method to eliminate unproductive symbols...
        def eliminate_inaccessible_symbols(self):
            # Method to eliminate inaccessible symbols...
```

2. **Grammar Creation**:
   - If no grammar is provided, the code prompts the user to input the grammar details interactively. This includes specifying the non-terminal symbols, terminal symbols, start symbol, and production rules.

3. **Grammar Type Checking**:
   - The implementation checks the type of grammar provided, determining whether it's a regular grammar, context-free grammar, or another type. This is essential for further processing and conversion.

4. **Conversion to Chomsky Normal Form (CNF)**:
   - CNF is a specific form of context-free grammar where all production rules are in one of two forms:
     - A -> BC (where A, B, and C are non-terminal symbols)
     - A -> a (where A is a non-terminal symbol and 'a' is a terminal symbol)
   - The implementation converts the input grammar to CNF through a series of steps:
     - Eliminating epsilon productions (productions that derive the empty string).
     - Eliminating unit productions (productions where one non-terminal symbol directly derives another).
     - Eliminating unproductive symbols (non-terminal symbols that cannot generate any terminal strings).
     - Eliminating inaccessible symbols (non-terminal symbols that cannot be reached from the start symbol).
     - Converting remaining productions to CNF by introducing new non-terminal symbols as needed.

5. **Unit Testing**:
   - The implementation includes unit tests to verify the correctness of the conversion process. These tests cover scenarios such as epsilon elimination, unit production elimination, and CNF conversion.

\
Logic Flow and User Interaction:

    if __name__ == '__main__':
        # Create an instance of the ChomskyNormalForm class
        variant = ChomskyNormalForm(V_n, V_t, P, S)
    
        # Print the grammar variables
        variant.print_variables()
    
        # Check the type of grammar
        variant.check_type_grammar()
    
        # Convert the grammar to Chomsky Normal Form
        CNF_Grammar = variant.convert_to_Chomsky_Normal_Form()

- The code follows a logical flow where each step builds upon the previous one, ultimately leading to the conversion of the grammar to CNF.
- User interaction is incorporated to allow users to input their own grammars or utilize predefined grammars for testing.

Testing and Validation:

- The unit tests ensure that the implemented functionality behaves as expected under different scenarios. These tests help validate the correctness and robustness of the conversion process.

\

### **Conclusion:**

The laboratory exercise on Chomsky Normal Form (CNF) has been a valuable learning experience in understanding grammar normalization techniques. Through this exercise, several key concepts and techniques have been explored, implemented, and tested. 

Firstly, we delved into the theoretical foundations of CNF and gained insights into its significance in formal language theory. Understanding the importance of CNF laid the groundwork for implementing the normalization process effectively.

Next, we embarked on the practical aspect of the laboratory by implementing a method for normalizing input grammars to CNF. The implementation was encapsulated within the `ChomskyNormalForm` class, providing a structured and organized approach to handle grammar normalization. Key methods such as `eliminate_epsilon_productions`, `eliminate_unit_productions`, and `eliminate_inaccessible_symbols` were implemented to transform grammars into CNF.

Moreover, unit tests were meticulously designed and executed to validate the functionality of the implemented methods. These tests ensured that the normalization process adhered to the rules of CNF and produced the expected results under various scenarios. By incorporating unit tests, the reliability and robustness of the implementation were enhanced, contributing to the overall quality of the solution.

Furthermore, the implementation offered flexibility by allowing users to input their own grammars interactively or utilize predefined grammars for testing purposes. This user-friendly approach facilitated experimentation and exploration, enabling a deeper understanding of grammar normalization techniques.

Overall, the laboratory exercise provided a holistic learning experience by combining theoretical knowledge with practical implementation and validation. It equipped us with essential skills in formal language theory, algorithm design, and software testing. Moreover, it emphasized the importance of structured problem-solving and code quality in developing reliable solutions.
